package main

import (
	"fmt"
	"runtime"
	"sync"
	"time"
)

/* 快速入门小结
1） 主线程是一个物理线程，直接作用在cpu上的。是重量级的，非常耗费Cpu资源。
2） 协程从主线程开启的，是轻量级的线程，是逻辑态。对资源消耗相对小。
3)  Golang的协程机制是重要的特点，可以轻松的开启上万个协程。其它编程语言的并发机制是一般基于线程的，开启过多的线程，资源耗费大，
	这里就突显Golang在并发上的优热了

MPG模式基本介绍：
	M： 操作系统的主线程[物理线程]
	P： 协程执行需要的上下文
	G:  协程

	MPG模式运行的状态1：
		1） 当前程序有三个M，如果三个M都在一个cpu运行，就是并发，如果在不同的epu运行就是并行
		2） M1,M2,M3正在执行一个G，M1的协程队列有三个，M2的协程队列有3个，M3协程队列有2个
		3） Go的协程是轻量级的线程，是逻辑态的，Go可以容易的起上万个协程。
		4） 其它程序c/java的多线程，往往是内核态的，比较重量级，几千个线程可能耗光cpu
	MPG模式运行的状态2：
		1） 分成两个部分来看
		2） 原来的情况是 M0 主线程正在执行G0协程，另外有三个协程在队列等待
		3） 如果GO协程阻塞，比如读取文件或者数据库等
		4)  这时就会创建M1主线程(也可能是从已有的线程池中取出M1)，并且将等待的3个协程挂到M1下开始执行，MO的主线程下的G0仍然执行文件io的读写。
		5） 这样的MPG调度模式，可以既让G0执行，同时也不会让队列的其它协程一直阻塞，仍然可以并发/并行执行。
		6)  等到G0不阻塞了，MO会被放到空闲的主线程继续执行(从已有的线程池中取），同时GO又会被唤醒。
*/

/* 1. 设置Golang运行cpu的个数 */

func CpuNum() {
	cpuNum := runtime.NumCPU()
	fmt.Println("cpuNum=", cpuNum)

	//可以自己设置使用多个cpu
	runtime.GOMAXPROCS(cpuNum - 1)
}

/* 2. 案例演示：
需求：
	现在要计算 1-200 的各个数的阶乘，并且把各个数的阶乘放入到map中。最后显示出来。要求使用goroutine完成
分析思路：
	1) 使用goroutine来完成，效率高，但是会出现并发/并行安全问題
	2) 这里就提出了不同goroutine如何通信的问题
代码实现:
	1) 使用goroutine来完成(看看使用gorotine并发完成会出现什么问题？[并发写错误|主线程比协程早结束])
	2）在运行某个程序时，如何知道是否存在资源竞争问题。方法很简单，在編译该程序时，增加一个参数 -race 即可
解决思路:
	不同goroutine之间如何通讯
		1）全局变量加锁同步
		2) channel
	使用全局变量加锁同步改进程序
		因为没有对全局变量 m 加锁，因此会出现资源争夺问题，代码会出现错误，提示 concurrent map writes
		解诀方案：加入互斥锁
		我们的数的阶乘很大，结果会越界，可以将求阶乘改成 sum += uint64(i)
*/

var (
	myMap = make(map[int]int, 10)
	//声明一个全局的互斥锁 [lock 是一个全局的互斥锁，sync 是包: synchorized 同步，Mutex : 是互斥]
	lock sync.Mutex
)

// test 函数就是计算 n!, 让将这个结果放入到 myMap
func test(n int) {
	res := 1
	for i := 1; i <= n; i++ {
		res *= i
	}
	//这里我们将 res 放入到myMap
	lock.Lock()    //加锁
	myMap[n] = res //concurrent map writes?
	lock.Unlock()  //解锁
}

func main() {
	CpuNum() //设置Golang运行cpu个数的函数调用

	// 我们这里开启多个协程完成这个任务[20个]
	for i := 1; i <= 20; i++ {
		go test(i)
	}

	time.Sleep(time.Second * 5) //主线程休眠5秒钟[主线程比协程早结束,协程执行不完或者根本不执行]
	//这里输出结果,变量这个结果
	lock.Lock()
	/* 读部分为什么需要加互斥锁，按理说5秒数上面的协程都应该执行完，后面就不应该出现资源竞争的问题了，但是在实际运行中，
	还是可能在红框部分出现（运行时增加-race参数，确实会发现有资源竞争问题），因为我们程序从设计上可以知道5秒就执行完所
	有协程，但是主线程并不知道，因此底层可能仍然出现资源争夺，因此加入互斥锁即可解决问题*/
	for i, v := range myMap {
		fmt.Printf("map[%d]=%d\n", i, v)
	}
	lock.Unlock()

}
